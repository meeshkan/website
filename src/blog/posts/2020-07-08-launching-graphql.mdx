---
title: Launching first-class support for automated GraphQL testing
description: Today we are announcing our full focus on automated testing of GraphQL servers.
slug: launching-automated-graphql-testing
date: 2020-07-23
authors: ["kenna"]
published: true
tags:
  - graphql testing
  - testing
  - automation
---

import { Button } from '@chakra-ui/core'

GraphQL is the future of APIs that we at Meeshkan, are investing in. **Today we are announcing our full focus on automated testing of GraphQL servers.**

![generate graphql tests](https://media.graphcms.com/locUhpIeToGAvxskJoda)

If this is your first time hearing about [Meeshkan](/) ‚Äî we're an automated testing service for the backend of your app using NLP and property-based testing. This announcement is us focusing deeper on developing future features unique to GraphQL testing. We wholeheartedly believe in the benefits the technology brings, as well as the need for better testing of GraphQL APIs.

*Does this sound interesting to you?*

<Button
  as="a"
  mt={4}
  href="https://app.meeshkan.com"
  aria-label="Create a free Meeshkan account."
  variantColor="red"
  borderRadius="sm"
  fontWeight={900}
  w={["100%", "100%", "auto"]}
>
  Create a free account
</Button>

Through-out this post, we'll walk through the warrants that lead us into betting our whole company's future on this technology - and how that affects you and your testing workflow!

## The evolution of API technology

Modern web APIs entered into the development world in 1999 in numerous implementations. One of the first business APIs, Salesforce debuted it's [XML also known as SOAP API](https://apievangelist.com/2012/12/20/history-of-apis/) in 2000.

#### RESTful

In the same year, [Roy Fielding](https://blog.readme.com/the-history-of-rest-apis/) and a few colleagues created a standard for APIs now regarded as REST. The doctoral dissertation detailing REST's standards was created with the input of the development community and contained several features that are critical/common practice today such as:

- using HTTP verbs (GET, PUT, POST, DELETE)
- stateless-ness (not containing context other than the specific request being made)
- cache-ability

The motivation was to give APIs a common set of standards to rally around and improve as a singular community. The vast majority of production APIs nowadays were originally built (and most are still) following the REST specification.

There are several challenges that the REST APIs afford. Singling out one challenge specifically related to testing ‚Äî the lack of generated documentation. Documentation is important for developers internal or external using the API. Many teams with REST APIs use OpenAPI or Swagger as a set of rules/specification that describes the format of their REST API. This is great for grokking what the API is capable of without reading the code, as well as providing the structure to create mock APIs to test against safely. OpenAPI specifications have [great tooling](https://stoplight.io/) but are brittle to API changes if manually created ‚Äî which is common practice.

#### GraphQL

The initial prototype of what is now known as GraphQL came to life in 2012 as a side project by a few Facebook developers facing challenges with their existing Newsfeed REST API. The static [specification](https://spec.graphql.org/) doc was released in 2015 and was warmly embraced by the development community. The API specification was designed with the developer who'd be using the API at the core focus and dealing with the tech to make it work after. Following the design, the features that the GraphQL specification landed include:

- Hierarchical nesting. Deeply defining the association of the data stored.
- Strongly typed. GraphQL types allow the client to predict what the query will return without knowing that much about the server.
- Introspection. Access to the entire type system/specification of a schema based on its endpoint. Remember GraphQL introspection as it will become important when speaking about automated testing of GraphQL APIs.

> **Introspection** | noun | the examination or observation of one's own processes.

Using an introspection query, we can conclude the GraphQL schema contents and types. With this ruleset of how the API should act and some Natural Language Processing magic ‚Äî we're able to generate meaningful tests.

For some more history of GraphQL, Honeypot.io has created an insightful documentary.

<Video url="https://www.youtube.com/embed/783ccP__No8" />

## Why we believe GraphQL will become the standard choice for building new APIs

Processes as precedented as creating an API are resistant to change. Thankfully at the core, the two technologies are very similar. Both REST and GraphQL send an HTTP request and receive a response. GraphQL has many elements of the REST standard built into its functionality with upgrades to its developer experience.

As a company that has been focused on [testing](/blog/what-is-the-testing-pyramid/), [mocking](/blog/on-device-mocking-of-rest-apis-in-react-native/), and [use](/blog/why-not-use-real-apis-in-tests/) of APIs for the past few years, GraphQL has been on our radar for a while. And several of our team were early adopters of GraphQL, teaching

We as a team are now bought into the GraphQL ecosystem in our own stack using 8base as our database. It's a MySQL DB with a GraphQL API and a beautiful UI - but the preconfigured endpoint that we could query against was the decision settler.

Another fantastic sign that GraphQL will continue to be in the stack-of-choice is the [growing number of software industry leaders](https://graphql.org/users/) making exactly that choice. GitHub, one of the largest and most used developer tools ‚Äî has a great GraphQL API and built-in documentation (totally necessary with the sheer mass of it).

## What does first-class GraphQL server testing look like?

The first thing to clarify is that several parts of a GraphQL API that can be tested. The GraphQL query(including queries, mutations, and subscriptions), the GraphQL resolver, and the GraphQL server.

Depending on how you build your GraphQL schema, there are different parts of testing that could serve your team!

1. If you use a service such as [GraphCMS](https://graphcms.com/) or [8base](https://www.8base.com/) - they take care of building and managing the resolvers and server for you. If this is the case for you, it'd be most helpful to encourage your provider to use Meeshkan as your tests would need to be frontend focused!
1. If you've built your GraphQL API from scratch using something like [Prisma](https://www.prisma.io/) or [Apollo](https://www.apollographql.com/), you're in charge of maintaining all three parts of the API. Meeshkan is currently a tool for the resolvers and the server-side of your API by making sure your auth is impenetrable, there aren't loopholes such as data accepted that will crash the server and more.

To us at Meeshkan, committing to first-class support meant making decisions regarding data science algorithms, communities to invest in, and testing capabilities ‚Äî **with GraphQL at the focus**. Quite possibly at the detriment to existing REST focused algorithms, other communities that might be interested in using Meeshkan, and the ability to test other API types. Of course, we keep a close eye on the divergence, but rest _cough ü§∑‚Äç‚ôÄÔ∏è_ assured if you're building with a GraphQL API, we're dedicated.

Some things we are [exploring on our roadmap](#next-steps)

## How automated GraphQL tests work on your server

Using your GraphQL endpoint, Meeshkan dynamically generates and executes on a series of property-based tests. There are a lot of moving pieces here that I want to break down the mechanics of.

![GraphQL endpoint](https://media.graphcms.com/vIthC9RqTUycJUhffO7c)

First off when importing a project into Meeshkan, during configuration you're asked for either the location or endpoint of your Open API specification and/or your project's GraphQL endpoint.

_Side note, if you're in the middle of a migration from REST to GraphQL or need to authenticate in REST but work with GraphQL, we support testing with both APIs in tandem!_

The biggest challenges of automated software testing are dynamically generating tests as the code changes and making sure those tests are meaningful and high quality.

Our approach to this large challenge is to base off of a concrete set of rules (in this case the GraphQL schema) and build from there using Natural Language Processing to generate reasonable inputs for fields with names like `email` and `password`. Starting from a sure yet dynamic base assures we know the results are actual, production reproducible scenarios.

## Benefits of using Meeshkan with your GraphQL API vs your REST API

Alongside the benefits of **_using_** a GraphQL API, there are several benefits of the inherent structure and functionality that make it more compatible for testing.

GraphQL APIs are strongly typed. And while we are big fans of [strongly typed patterns in programming](/blog/functional-programming-for-frontend-pipe/) at Meeshkan, I digress. The native feature of a GraphQL schema, called introspection, allows the entire type structure and relationships to be queried on-demand, and dynamically as the API evolves.

Another feature that provides testing value, is the documentation of relationships. One feature we're passionate about at Meeshkan is stateful testing. We believe (amongst lots of other people) that for your tests to be meaningful, they should replicate a user in the wild ‚Äî also known as your production app.

Most tools that _automatically_ test your app, read the code statically and make inferences. Meeshkan imitates a user with our integration tests. Stateful tests create users with traceable/reproducible steps that center around logic-heavy functions in your app. Some examples where stateful testing is invaluable include authorization, authentication, and transactions (currency, databases, etc).

GraphQL stores information about how mutations relate to queries giving confidence to our stateful testing algorithms. For example, `tests` can be traced to `createTest` and `createManyTests`. With a REST API, there are common patterns that our NLP algorithms can pick up ‚Äî but assumptions make for a lot less confident tests. For more complex relationships, we support custom GraphQL directives.

## The future of testing GraphQL as Meeshkan sees it

I'm super stoked to finally announce what we've been brewing internally and working with early adopters. We've got a vision that testing should be intertwined into your dynamic coding workflow, rather than a disconnected, easily skippable step. We're working hard to achieve this, and starting in integration testing.

We're energized by the GraphQL community and the future that we envision we can help developers achieve. A future where 'to test or not to test' is no longer a difficult decision.

### Next steps

- Allowing you to connect your client to test queries, mutations, and subscriptions used in production.
- Creating explicit test cases where you define the queries you'd like to run each test
- Monitoring auth (authentication and authorization) rules, notifying when a user scope has changed
- Is there something that you'd like to see in your testing workflow? [We want to hear from you!](/contact/)
