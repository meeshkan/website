---
title: Introducing Wall
description: tl;dr Wall doesn't exist, help me build it.
slug: introducing-wall
date: 2020-05-11
authors: ["mike"]
published: false
tags:
  - functional
  - lisp
  - haskell
  - scheme
---

_This article was originally published on August 14, 2019._

Ever since my first piece of code returned an error, which is the first thing that happened when I ran my first piece of code, I have been fascinated with errors. [Division by zero](https://docs.python.org/3/library/exceptions.html#ZeroDivisionError). `undefined is not an object`. [Index Out of Bounds Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/IndexOutOfBoundsException.html). Maximum call stack size exceeded. I’ve seen them all, and while I harbor a certain affection for them, I would like if I experienced slightly less of them in my day-to-day work. In general, I’m cool with errors that stop me from doing stupid things, like forgetting to close parentheses, but it’s the errors that pop up once the software is running that really get on my nerves.

Recently, I had some time off from work to decompress, and while most people probably would use time like this go to Majorca or binge-watch Stranger Things, I wrote documentation for a non-existent programming language called [Wall](https://wall-lang.netlify.app/).

I decided to sketch out Wall because I am tired of shit breaking all the time, especially when working with files, SQL databases and REST APIs. So I consider this an investment in my future vacations — if fewer stuff breaks, then I will have more time to go to Majorca and binge-watch Stranger Things. Hopefully, work on Wall will result in a full-featured programming language that finally nails the imminently solvable, billion-dollar error handling problem that has plagued software development since mankind witnessed the first out-of-memory error.

## What is Wall?

Wall is a dialect of Lisp that strives for Zero Runtime Errors™. It is the coding equivalent of bumper bowling with bumpers that converge inwards toward the middle pin and a lane that has a slight downward slope. It has some sweet syntactic sugar to avoid monstrosities like `(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 6)))))` and, in the spirit of Lisp, it is purely functional.

Wall’s killer feature is the validation of function invocation at compile time. So if `f` is a function and `x` is an input to that function, then compilation will fail if `x` is not guaranteed to be in the domain of `f`. To build up to this feature, I will explore four notions in Wall: sets, functions, validators and rules. Along the way, you’ll see lots of other nifty bits of Wall that are more thoroughly explained in its [documentation](https://wall-lang.netlify.app/).

## Sets

In Wall, there are no Objects. There are no Maps. There are no Classes. There are no Interfaces. There are just [Functions](https://wall-lang.netlify.app/functions-1.html).

```
// a function that maps 1 to 2 and 3 to 4
f = { 1 2 3 4 }
f 1 // result is 2
```

Like in Haskell, functions can only take one argument, just like maps or objects can only ever take one key or accessor. Functions can be defined on a finite domain (like above) or on an infinite domain using a variety of pre-defined functions. `fmap`, for example, is a function that takes a set `s`, a function `m`, and returns a function mapping elements of set `s` to values obtained by applying `m` to each element of `s`.

```
a = fmap :[1 2] (+ 3)
== a { 1 4 2 5 } // true
just-42 = fmap everything (just 42)
just-42 'foo // result is 42
// a function that maps everything but the number 0 to itself
identity-0 = fmap (s-e everything 0) identity
identity-0 1 // result is 1
identity-0 0 // compilation error because 0 is not in the domain
```

In the example above, `s-e` subtracts an element from a set, so `identity-0` is defined on every possible value in Wall _except_ 0. `just` is a function that returns whatever is passed to it.

Using `fmap` makes working with dependent types a piece of cake. In languages like TypeScript and Haskell, it is really hard to specify a function signature that accepts only positive integers and throws a compile-time error if this is not the case. In Wall, it is trivial.

```
valid-ages = filt int (< 0)
make-one-year-older = fmap valid-ages (+ 1)
make-one-year-older 5 // 6
make-one-year-older -1 // compilation error
```

## Validators

A validator is a special type of function in Wall that maps `everything` to either `true` or `false`.

```
ill-accept-anything = fmap everything (just true)
heck-no = fmap everything (just false)
```

Validators can be used with the [`fun`](https://wall-lang.netlify.app/functions-4.html) function to compose function domains that would be tedious to define via operations on sets. In this way, they resemble “normal” function definitions.

```
add-ints = fun [int? int?] (a0 + a1)
```

The `a0` and `a1` above come from a bit of syntactic sugar, but they correspond to the arguments `int?` and `int?`.

Wall ships with hundreds of predefined validators that allow for some pretty snazzy compile-time verification.

```
person? = object? {
  name' string?
  (maybe? age') int?
  (starts-with? 'x-) string?
}
say-hello = fun [person?] (++ "Hello " a0)
say-hello { 'name 'Mike } // "Hello Mike"
say-hello { 'name 'Mike 'age 36 } // "Hello Mike"
say-hello { 'name 'Mike 'age 36 'x-likes 'reading } // "Hello Mike"
say-hello { 'name 'Mike 'last-name 'Solomon } // compile error
```

Above, the function `object?` constructs a validator from key-value pairs of required and optional arguments, including pattern validators like `starts-with?`. In most languages, it is impossible to specify hybrid objects like this that behave like a class with fields and a map whose strings have specific properties. In Wall, this is easy, and it allows for creating compile-time validators for things like OpenAPI and JSON Schema.

Furthermore, Wall keeps an internal record of what functions have been applied to what values. This allows it to determine if unknowns, like a string returned from an API call, have been sufficiently validated to be consumed by functions.

## Rules 

Of course, a binary yes/no validation is useful in some cases, but in a lot of scenarios, it is more desirable to modify values on the fly. For example, if we receive a string with whitespace that is supposed to be a username, we probably do not want to reject the string entirely, but rather trim the whitespace and use the trimmed value. To accomplish this, Wall has a function `rules` that acts on input to validate it and, if necessary, transform it.

```
username-rule = rules [string? [has-whitespace? remove-whitespace]]
hello-user = def [username-rule] ++ "Hello: " a0
hello-user "  Amy " // "Hello Amy"
hello-user 5 // compilation error
```

## Other cool stuff in Wall 

Wall has some pretty jazzy features, including:
* pattern matching using functions;
* local scopes for any syntactic construct;
* co-located unit tests and code

…and a [whole lot more](https://wall-lang.netlify.app/musings.html). I would absolutely love any and all feedback on the language design so far, and if you are courageous enough to look at implementation sketches, the [Wall branch](https://github.com/mikesol/wall/tree/wall) has an embryonic parser and input validator.

## What's in a name 

Wall is named after Larry Wall, the inventor of the Perl programming language. While I have never met Larry, I have always loved Perl for its bold vision and quirky idiosyncrasies. I still use `perl` for most of my one-liners, Larry’s quotable quips are staples in my personal lexicon, and I think Larry’s answer to the question [“What are 5 programming languages everyone should know?”](https://www.youtube.com/watch?reload=9&v=LR8fQiskYII) should be required watching for the 21st century.

Of course, “wall” is also a noun. It is unfortunate that, with so much discussion in the air about building walls to separate people, we don’t talk enough about how walls unite people. Walls like the wailing wall, the Vietnam War memorial, and any awesome piece of street art, bring people together to think, meditate, remember and be astounded. Wall’s goal is similar: by composing together a bunch of small bricks, I hope it turns into an object of wonder, enlightenment and community for years to come.

Interested in contributing to Wall? Even if it's just an idea, head on over to the [GitHub repo](https://github.com/mikesol/wall) and make your presence known!
