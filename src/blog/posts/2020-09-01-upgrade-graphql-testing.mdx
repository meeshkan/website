---
title: Seven easy wins for testing your GraphQL API
description: How to upgrade your GraphQL testing past using GraphiQL in 7 easy ways including other tooling.
date: 2020-09-01
authors: ["mike"]
published: true
slug: brittle-tests
tags:
  - testing
  - apis
  - graphql
---

GraphQL is instantly testable. When you spin up a sample project like [The Meeshkan Bank](https://github.com/meeshkan/bank), you get an interactive [GraphiQL playground](https://www.electronjs.org/apps/graphiql) for free. This is a game changer - we get documentation, a sandbox, auto-completion, and human-readable error messages for free.

GraphiQL is one example of how GraphQL is the most testable framework in history. In this article, I'll discuss seven strategies for progressing your your GraphQL testing past the GraphiQL, all of which are implementable in less than hour.

## Enums and scalars

GraphQL gives you the power to define custom enums, scalars and directives. These make validation easier for your entire team.

Compare the two ways of defining color below.

```graphql
enum Color {
  Burnt_sienna
  Fulvous
  Mindaro
  Skobeloff
  Vermilion
  Red
}

type Region0 {
  color: Color
}

type Region1 {
  color: String
}
```

I've seen a lot of teams use a well-defined scheme like a color scheme and yet, when it comes time to implement their GraphQL API, they use a `String` instead of an `enum`. This leads to a lot of unnecessary validation burden. Let your GraphQL framework do the heavy lifting for you by using enums!

The same is true for scalars.

```
scalar Gmail_email
scalar Other_email
```

Even though graphql can't validate a `Gmail_email` out of the box, you can write [_one recipe_](https://github.com/absinthe-graphql/absinthe/wiki/Scalar-Recipes) and be done with it instead of validating gmail emails throughout your code base.

I know I promised this article would be about testing, but the **best test is no test at all because someone else wrote it for you**. Using enums and scalars taps leverages GraphQL's well-tested and well-defined behavior to supercharge your APIs.

## 2. Schema linting

While GraphQL schemas are pretty open-ended, there are certain conventions that will leave your colleagues scratching their heads. For example:

```graphql
type Post {
  author: String
  content: String
  tags: [String]
}
```

Let's take a peek at `tags`. We are saying "You may get an array of tags, or you may get null, and inside the array, there will be some strings and some nulls." What?!? What we probably actually wanted was a list of strings that may be empty:

```graphql
type Post {
  author: String
  content: String
  tags: [String!]!
}
```

Just because you _can_ use the type system a certain way in GraphQL doesn't mean you should. Usually, when types are used this way, it is not intentional - it just means someone didn't think it through. That's totally normal, but it leads to a lot of confusion in teams and is totally avoidable by using a _GraphQL schema linter_.

My favorite graphql schema linter is called [`graphql-schema-linter`](https://github.com/cjoudrey/graphql-schema-linter), and it catches this sort of problem and many more! If you're coding in VSCode, you're using a coding linter to add squiggly yellow and/or red lines under your code as your work. Your GraphQL schema should get the same royal treatment! You can add it as part of your deployment pipeline to make sure your schema is nice and tidy before it ships to the world.

Like custom enums and scalars, you get **tests for free** by using a schema linter. Who doesn't like free stuff?!? On that subject, and incidentally, my company is drop shipping a ton of free swag, ask for yours [here]()!

## 3. Type-safe resolvers

Resolvers in most GraphQL frameworks are born type-safe, meaning that it will give you an `String` if you need an `String` and otherwise will throw an error back to the client. But what about the return types? To make sure you're returning the correct types, you can [auto-generate type-safe resolvers](https://graphql-code-generator.com/). You can then use these resolvers as a middle-layer between your business logic and your graphql framework. They will make sure that, however messy the typing is inside your business logic, the value going to the resolver is type-safe at _compile time_. Most GraphQL frameworks will throw a _runtime error_ as well if there is an issue with type safety, but that's exactly the type of breakage you want to avoid in production. Given how easy it is to generate type-safe resolvers from a schema (it literally takes seconds - try the site!), you can use this as an added linting layer in your code.

## 4. Build a contract

Up until now, I haven't asked you to do any testing in the traditional sense. By using type-safety and linting, you're leveraging tests that _other people_ write, which is the best way to test!

But at a certain point, situations crop up where writing tests make sense. In my opinion, the most important situation where this comes up is to **enforce a contract**. As a backend GraphQL developer, you've made a contract (explicit or implicit) with the users of your GraphQL API that it will work as expected. While your GraphQL API can be used a lot of different ways, a contract emerges over time of how it is _actually_ used.

Take, for example, a popular service like [CodeSandbox](https://codesandbox.io). They have a full-featured GraphQL API, but when you use [codesandbox.io](https://codesandbox.io), if you open your network tab, you'll see that the front-end calls the backend GraphQL API in a limited number of pre-defined ways. _This_ is the contract I'm talking about. It won't add much value to their business to polish unused corners of their API, but they really need to make sure they don't break their contract with their front-end.

The good news is that, even here, you don't need to write a single test! Contract-based testing frameworks like [pact.io](https://pact.io) will figure out what this contract is _automatically_ and alert you when it is broken. It will even generate test cases to validate this contract when you build and deploy your code. Deploying a pact server takes 1-2 devs under a day, and you'll gain that time back in a month.

## 5. Property-based testing

This section is not relevant to all GraphQL backend devs, but if you are considering opening up your GraphQL API to people outside your company or you want to invest in security-testing, read on!

If you open up your GraphQL API to the world, the contract becomes a lot broader because it is defined by potential usage instead of actual usage. While regular usage patterns will emerge, you are always one unexpected use-case away from breakage when your API exists out in the wild.

Before you advertise your GraphQL API for public use, you should write some property-based tests for it. **Property-based tests** use randomly-generated data to confirm that a set of properties hold for a given system under test. The good news is that, for a GraphQL API, a lot of the properties are pre-defined by virute of the schema. While a lot of the methods I describe above (ie type-safe resolvers) can validate many of these properties without additional tests, nasty corner cases can arise, like having code that implicitly expects a positive integer and crashes otherwise (we see this all the time at Meeshkan!). Property-based tests reveal this type of bug.

The good news is that, to set up basic property-based tests for your graphql API, you don't need to write a single test. You can use a framework like [schemathesis](https://schemathesis.readthedocs.io/en/stable/graphql.html) to **automatically generate property-based tests** for your GraphQL API.

For some more resources on property-based testing, you can check out these articles:

- [Finding and fixing bugs in your tests with fast-check](https://meeshkan.com/blog/property-based-testing-bugs/)
- [Introduction to property-driven development](https://meeshkan.com/blog/introduction-to-properties-driven-development/)

## 6. Generate a model

One of the hardest bugs to catch in testing is the software equivalent of DC-offset. In audio, DC-offset is when you have a little bit of direct current going into a recording system, which makes the microphone more rigid so that it doesn't vibrate as freely. That results in a lower variation of amplitude, which results in poor sound quality. Entire albums have been plagued by DC-offset, and it's super hard to undo once it's done.

In software, something like DC-offset occurs when a piece of software _should_ return something (ie robust search results) but in reality returns something really limited (ie the 3-4 top results) due to a malformed query. It is super hard to catch that, and it has the same effect as DC-offset on an album: underwhelming performance.

Software DC-offset has a particularly crippling effect on businesses because it is immediately felt by users and leads to an underwhelming sensation. If you have a menu that accidentally only shows two options, followed by a color palette that accidentally only shows one color, followed by a list of your creations that does not paginate, your users will bounce to a competitor.

Fixing DC-offset in software has been one of the hardest problems in testing, but GraphQL makes it much easier to do this than before. Using the same methods as property-based testing, you can generate a _mock GraphQL server_. This is done by generating fake _output data_ instead of measuring fake _input data_.

Meeshkan has a tool called [hmt](https://github.com/meeshkan/hmt) that helps you automatically generate mock servers. If you run them continuously on a server to generate "garbage" data and then compare how this data is distributed compared to your real data, you'll notice when the histogram of the generated data is radically different than the real data. Glancing over 2-3 of these charts once a week can help you nip software DC-offset in the proverbial bud!

## 7. Meeshkan

When I talk about all of the solutions above, I'm doing so with a sort of "ideal GraphQL testing solution" in the back of my head. What would ideal GraphQL testing look like? To me, it is an infinite supply of really fast, really smart QA engineers that can guess what I wanted to do, measure what my service is actually doing, and present the diff in a way I can understand.

That sounds like science fiction, but at Meeshkan, that's what we're in the business of doing. We use artificial intelligence to predict, with high confidence, how we think you wanted your app to behave, and we generate test reports based on this. You can get started on our [free tier](https://app.meeshkan.com) to see how this works for your GraphQL API!

## Parting shot

In this article, I promised to offer you seven testing solutions for GraphQL, and you may be surprised to see that I didn't show you how to write a single test. That's because, in 2020, writing tests is no longer the most sure-fire way to test your software, just like writing code is not the most sure-fire way to build software. Of course, you have to write some code, and you probably should write some tests, but so many tools and libraries exist out there that you can get very far just by composing together high-quality services that communicate across well-defined interfaces with limited surface area.

I hope that you get the chance to try out some of the tools and technologies linked in this article. Those who consume your GraphQL API will thank you for it!
