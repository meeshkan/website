---
title: Seven ways to improve your GraphQL API in less than an hour
description: You've built a great GraphQL API. Now it's time to give it rock-solid reliability!
date: 2020-08-17
authors: ["mike"]
published: true
slug: improve-graphql-api
tags:
  - testing
  - apis
  - graphql
---

At Meeshkan, we work with lots of teams building GraphQL APIs. In doing so, we've seen several techniques that have provided high value to teams with minimal effort. These are some amazing force multipliers, and we thought it'd be nice to collect them into one article that you can use as a checklist.

All of the techniques that make the cut below take less than an hour to implement. As we like to brag a bit (can you blame us?) our solution will be one of them, but there are many others that are equally deserving of your attention! They're all complementary, and we think you'll get a lot of milage out of them. Enjoy!

## 1. Enums and scalars

GraphQL gives you the power to define custom enums, scalars and directives. These make validation easier for your entire team.

Compare the two ways of defining color below.

```graphql
enum Color {
  Burnt_sienna
  Fulvous
  Mindaro
  Skobeloff
  Vermilion
  Red
}

type Region0 {
  color: Color
}

type Region1 {
  color: String
}
```

I've seen a lot of teams that use a `String` even though their business case would warant an `enum`, like the color example above. This leads to unnecessary validation burden. Let your GraphQL framework do the heavy lifting for you by using enums!

The same is true for scalars.

```
scalar Gmail_email
scalar Other_email
```

Even though graphql can't validate a `Gmail_email` out of the box, you can write [_one recipe_](https://github.com/absinthe-graphql/absinthe/wiki/Scalar-Recipes) for your entire codebase.

If you're already well into a GraphQL project, it may be impossible to modify your API, but if you're adding to it or starting a new project, building with an enum-first and scalar-first mindset saves tons of time down the line and takes minutes to set up.

## 2. Schema linting

While GraphQL schemas are pretty open-ended, there are certain design choices that will leave your colleagues scratching their heads. For example:

```graphql
type Post {
  author: String
  content: String
  tags: [String]
}
```

Let's take a peek at `tags`. We are saying "You may get an array of tags, or you may get null, and inside the array, there will be some strings and some nulls." What?!? What we probably actually wanted was a list of strings that may be empty:

```graphql
type Post {
  author: String
  content: String
  tags: [String!]!
}
```

Just because you _can_ use the type system a certain way in GraphQL doesn't mean you should. Usually, when types are used this way, it is not intentional - it just means someone didn't think it through. That's totally normal, but it leads to a lot of confusion in teams and is totally avoidable by using a _GraphQL schema linter_.

Here are a few linters and validators you can use in your GraphQL pipeline starting today. If you're developing in JavaScript, all it takes is adding a linting step to your `package.json` file and you get automatic linting with every build.

- [GraphQL Inspector](https://graphql-inspector.com/)
- [`graphql-schema-linter`](https://github.com/cjoudrey/graphql-schema-linter)

Also, have a look at [GraphQL config](https://graphql-config.com/introduction) for a nice way to set these things up to run automatically in your IDE so that you can reuse the same linting and validation config in a variety of setups.

## 3. Type-safe resolvers

Resolvers in most GraphQL frameworks are born type-safe, meaning that it will give you an `String` if you need an `String` and otherwise will throw an error back to the client. But what about the return types? To make sure you're returning the correct types, you can [auto-generate type-safe resolvers](https://graphql-code-generator.com/). You can then use these resolvers as a middle-layer between your business logic and your graphql framework. They will make sure that, however messy the typing is inside your business logic, the value going to the resolver is type-safe at _compile time_. Most GraphQL frameworks will throw a _runtime error_ as well if there is an issue with type safety, but that's exactly the type of breakage you want to avoid in production. Given how easy it is to generate type-safe resolvers from a schema (it literally takes seconds - try the site!), you can use this as an added validation layer in your code.

## 4. Meeshkan

One of the most exciting advancements in software development is the use of AI to learn how software works and generate tests based on those learnings. At [Meeshkan](https://meeshkan.com), we use NLP libraries like [spacy](https://spacy.io/) and property-based testing frameworks like [QuickCheck](https://en.wikipedia.org/wiki/QuickCheck) to automatically understand and test GraphQL APIs.

Signing up for Meeshkan takes minutes, and you'll see your first test report within hours. We provide a generous [free tier](https://app.meeshkan.com) that makes use of our most popular AI algorithms, and our paid tier runs over 10,000 tests on each project every day for added security.

## 5. Build a contract

As a backend GraphQL developer, when you launch an API and someone else uses it, a _de facto_ contract emerges around yout API. While your GraphQL API can be used a lot of different ways, this contract represents how it is _actually_ used by your users.

Take, for example, a popular service like [CodeSandbox](https://codesandbox.io). They have a full-featured GraphQL API, but when you use [codesandbox.io](https://codesandbox.io), if you open your network tab, you'll see that the front-end calls the backend GraphQL API in a limited number of pre-defined ways. _This_ is the contract I'm talking about. It won't add much value to their business to polish unused corners of their API, but they really need to make sure they don't break their contract with their front-end.

The good news is that this contract can be enforced automatically with a little bit of setup. Check out [pact.io](https://pact.io), which will figure out what this contract is _automatically_ and alert you when it is broken. It will even generate test cases to validate this contract when you build and deploy your code. Deploying a pact server in a local environment can be done in less than an hour, and you'll be amazed how powerful the idea is!

## 6. Property-based testing

This section is not relevant to all GraphQL backend devs, but if you are considering opening up your GraphQL API to people outside your company or you want to invest in security-testing, read on!

If you share your GraphQL API with the world, the contract becomes a lot broader because it is defined as much by potential usage as by actual usage.

Before you advertise your GraphQL API for public use, you should write some integration tests. While we will cover integration testing GraphQL in a separate article, in this article, I'd like to mention one method because of how powerful it is in very little time. That method is **property-based testing**.

Property-based tests use randomly-generated data to confirm that a set of properties hold for a given system under test. The good news is that, for a GraphQL API, a lot of the properties are pre-defined by virute of the schema. While a lot of the methods I describe above (ie type-safe resolvers) can validate many of these properties without additional tests, nasty corner cases can arise, like having code that implicitly expects a positive integer and crashes otherwise. Property-based tests reveal this type of bug.

The good news is that, to set up basic property-based tests for your graphql API, you don't need to write a single test. You can use a framework like [schemathesis](https://schemathesis.readthedocs.io/en/stable/graphql.html) to **automatically generate property-based tests** for your GraphQL API.

For some more resources on property-based testing, you can check out these articles:

- [Finding and fixing bugs in your tests with fast-check](https://meeshkan.com/blog/property-based-testing-bugs/)
- [Introduction to property-driven development](https://meeshkan.com/blog/introduction-to-properties-driven-development/)

## 7. Generate a model

One of the hardest bugs to catch in testing is the software equivalent of DC-offset. In signals like audio, [DC-offset](https://en.wikipedia.org/wiki/DC_bias) is when you have a little bit of direct current going into a system, which makes the receiver (ie microphone) more rigid so that it doesn't vibrate as freely. That results in a lower variation of amplitude, which results in poor signal (sound) quality.

In software, something like DC-offset occurs when a piece of software _should_ return a range of values (ie robust search results) but in reality returns a subset of this range (ie the 3-4 top results) due to a malformed query. It is super hard to catch this type of bug, and it has the same effect as DC-offset on an album: underwhelming performance.

Software DC-offset has a particularly crippling effect on businesses because it is immediately felt by users and leads to churn. If you have a menu that accidentally only shows two options, followed by a color palette that accidentally only shows one color, followed by a list of your creations that does not paginate, your users will bounce.

Fixing DC-offset in software is one of the hardest problems in testing, but GraphQL makes it much easier to do this than before. Using the same methods as property-based testing, you can generate a _mock GraphQL server_. This is done by generating fake _output data_ instead of measuring fake _input data_.

Projects like [graphql-tools](https://www.graphql-tools.com/docs/mocking/) automatically generate mock servers from a schema in less than a minute. If you compare their output to your production logs, which can be done with tools like Jupyter and matplotlib, you'll notice when the histograms are radically different. Glancing over 2-3 of these charts once a week can help you nip software DC-offset in the proverbial bud!

## Parting shot

I hope that you get the chance to try out some of the tools and technologies linked in this article. Those who consume your GraphQL API will thank you for it, and you'll have a much more pleasurable experience developing it!
