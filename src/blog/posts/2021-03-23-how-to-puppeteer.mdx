---
title: Meeshkan generated Puppeteer scripts with Jest and GitHub actions
description: UI tests can be time consuming. Have your users write tests for you with Meeshkan. This is the 'how to' after you've downloaded those tests.
slug: how-to-puppeteer-jest-github-action
date: 2021-03-23
authors: ["kenna"]
published: true
---

![Download the Puppeteer script screenshot](https://media.graphcms.com/4dFENJJrRNCi7G427EQ6)

This blog is on the tail of some great news â€” Meeshkan now let's you export test case scripts! That changelog can be referred to [here](/changelog/15-03-2021). This article is a great read if you're **already a Meeshkan user and looking to implement the scripts** in your workflow.

## Some backstory

Meeshkan as a _"UI tests generated by your users and run automatically"_ â€” product was born in September of 2020. Before then we'd worked on all sorts of testing, mocking, and ambitious dev projects but they all culminated to this direction.

This is to say that downloading tests are a stepping stone to our product vision. It's an incredibly impactful step that allows users of Meeshkan to close the full loop of the promised `record` production user behavior, `create` test cases, `run` automatically against your staging branch.

## Puppeteer and why we chose it

> Puppeteer is a Node library which provides a high-level API to control headless Chrome or Chromium over the DevTools Protocol. It can also be configured to use full (non-headless) Chrome or Chromium. <br /> - [Google Developers](https://pptr.dev/)

Introducing new dependencies into someone's stack is a sacred thing. We'd like to continue building by our value of â€” slotting into your workflow wherever you might be or the tooling you might be using. Meeshkan records browser events that can be transcribed into any browser scripting technology and we were down to Selenium vs Puppeteer. We internally have a lot of experience with the Puppeteer API and made the decision to go with Puppeteer for better support and developer experience.

## Now, let's implement!

With this script, we have boundless possibilities to the extent it's implemented. We'll walk through 3 levels of complexity and the benefits that they offer.

**All of the following steps will require you to work with a downloaded script from a test case in Meeshkan.** Going to an individual user story and click the _more_ button. In the top right a drop down with the button "Download Puppeteer script" should be clicked and a file with the user story's name `.js` will be downloaded.

In whichever project you're working with the test (ideally right next to the code it tests), also install `puppeteer`.

```bash
yarn install puppeteer --dev
```

### 1. Out of the box Puppeteer

With your JavaScript file downloaded, open it in the IDE of your choice (I'm using VS Code) to take a look. This is instructions to a browser on what to do. This is what my file looks like (I've added a few comments for clarity):

```js
// set-a-new-authentication-token.js
const puppeteer = require("puppeteer")

;(async () => {
	const browser = await puppeteer.launch({ headless: false })
	const page = await browser.newPage()

	await page.goto(`https://app.meeshkan.com/meeshkan-webapp`)
	await page.setViewport({
		width: 1903,
		height: 1057,
		deviceScaleFactor: 1,
	})
	await new Promise((r) => setTimeout(r, 5000))

	// Navigate to the settings page
	const button = await page.$x(
		"/html/body/div[1]/div/nav/div/div[4]/div/button[2]"
	)
	await button[0].click()
	await new Promise((r) => setTimeout(r, 5000))

	// Navigate to the details section
	const link = await page.$x(
		"/html/body/div[1]/div/nav/div/div[2]/div[2]/div/div[2]/a[3]"
	)
	await link[0].click()
	await new Promise((r) => setTimeout(r, 5000))

	// Fill in the key input
	const input1 = await page.$x(
		"/html/body/div[1]/div/div/div/div[6]/form/div[2]/input"
	)
	await input1[0].click()
	await (
		await page.$x("/html/body/div[1]/div/div/div/div[6]/form/div[2]/input")
	)[0].type("test", { delay: 100 })
	await new Promise((r) => setTimeout(r, 5000))

	// Fill in the value input
	const input2 = await page.$x(
		"/html/body/div[1]/div/div/div/div[6]/form/div[2]/input"
	)
	await input2[0].click()
	await (
		await page.$x("/html/body/div[1]/div/div/div/div[6]/form/div[3]/input")
	)[0].type("hello-world", { delay: 100 })
	await new Promise((r) => setTimeout(r, 5000))

	// Submit the form
	await page.click("button", { text: "Save token" })
	await new Promise((r) => setTimeout(r, 5000))

	// Delete the cookie (cleanup)
	const button1 = await page.$x(
		"/html/body/div[1]/div/div/div/div[6]/div[5]/button"
	)
	await button1[0].click()
	await new Promise((r) => setTimeout(r, 5000))

	await browser.close()
})()
```

This is a test I'm setting up for the Meeshkan webapp to make sure that authentication tokens can be sucessfully added, that was created from several users repeating the same action.

We're going to manually 'test' to see if this user story can run or if users can perform this action. You'll want to be cd'd into the directory with the script and use node to invoke the Puppeteer script.

```bash
node ./tests/set-a-new-authentication-token.js
```

You should see the a browser pop open and be driven with out any clicks. Sometimes this can take a few seconds! There are two ways you can know if the test is successful.

1. Watching â€” Does the correct thing happen before your eyes?
2. Terminal output â€” does the terminal complete with out complaining or are there errors?

The type of errors that could pop up are those of basic assertions. The type of errors that could pop up include:

- A page doesn't exist
- An element doesn't exist
- An element does exist but an action cannot be performed on it

For some this is a bit too manual, let's see if we can add a bit of automation to this.

### 2. Puppeteer on commit with GitHub actions

I really couldn't rave enough about GitHub actions and how smooth the workflow is (once you get past the unforgivingness of yaml syntax that is ðŸ˜‰).

Navigating to the "Actions" tab in GitHub, let's create a new workflow. This will open a draft editor with a folder/file structure of `.github/workflows/main.yaml` in the root of your repository.

![Create a new GitHub action](https://media.graphcms.com/jxn1HgOVSNGy4dXq1XcM)

The initial yaml file will have comments at almost every line explaining the make-up of a GitHub Action file.

1. First we'll change the name of the Test suite to "Meeshkan tests"
2. Then change the `on:` or frequency of test runs to `push`
3. Create our first job that first sets up the node environment then installs dependencies and runs the Puppeteer script.

```yaml
#  main.yaml
name: Meeshkan tests

on: push

jobs:
  trigger-puppeteer:
  name: Run the puppeteer scripts generated by Meeshkan
  runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v1
        with:
          node-version: '14'

      - name: Install dependencies & Run test
        run: |
          yarn install --prefer-offline --frozen-lockfile
          node ./tests/set-a-new-authentication-token.js
```

Now, what we previously did locally will run per-commit via GitHub actions.

This is still light on the assertions though. In the next step we'll look into defining more conditions in order for the test to succeed.

### 3. Writing assertions with Jest

[Jest](https://jestjs.io/) is a super popular JavaScript testing framework that allows you to write tests simply. This is the option that Meeshkan internally chose. We already had Jest installed in our repo, so it was an easy extension for us.

In order to extend Jest with Puppeteer, we will use [jest-puppeteer](https://github.com/smooth-code/jest-puppeteer). I'd suggest following the setup details in this repository. The important bits I found:

- Your `jest.config.js` should now define the preset as `jest-puppeteer`.
- Make sure you don't have a testEnvironment set from a previous or default configuration, the package will take care of this.
- If you're using TypeScript, check out [this documentation](https://datacadamia.com/web/javascript/jest_puppeteer) as well.

Writing assertions are strait forward functions. We'll be describing a user story which Jest will call a test suite, declaring it's expectations at certain points. I will be breaking the suite up into logical steps via assertions. First let's look at one step.

```js
// This + the jest-puppeteer preset will handle our environment and expose some new functionality like '.toMatch()'
import "expect-puppeteer"

describe('Save an authentication token', () => {
// Setup & steps
	it('clicks submit on the form', async () => {
		await page.click('button', { text: 'Save token' });
		await expect(page).toClick('button', { text: 'Save token' });

		await new Promise((r) => setTimeout(r, 5000));
	}, 100000);
// More steps
}
```

Describe expects it statements and succeeds or fails depending on each individual assertion. Let's make sure this works locally before moving on. The full file we're operating with is:

```js
// meeshkan-exports.test.js
import "expect-puppeteer"

describe("Save an authentication token", () => {
	jest.setTimeout(100000)

	beforeAll(async () => {
		await page.setCookie({
			name: "a0:session",
			value: process.env.COOKIE,
			domain: process.env.TEST_URL.startsWith("localhost")
				? "localhost"
				: process.env.TEST_URL,
		})
		await page.goto(
			`${
				process.env.TEST_URL.startsWith("localhost") ? "http://" : "https://"
			}${process.env.TEST_URL}/meeshkan-webapp`
		)
		await page.setViewport({
			width: 1813,
			height: 1057,
			deviceScaleFactor: 1,
		})
		await new Promise((r) => setTimeout(r, 10000))
	})

	it("loads the dashboard", async () => {
		await expect(page).toMatch("Confidence score")
	})

	it("should navigate to the settings page", async () => {
		const button = await page.$x(
			"/html/body/div[1]/div/nav/div/div[4]/div/button[2]"
		)
		await button[0].click()
		await page.waitForNavigation()
		await new Promise((r) => setTimeout(r, 1000))
	}, 100000)

	it("fills out the form", async () => {
		// Navigate to the details section
		const link = await page.$x(
			"/html/body/div[1]/div/nav/div/div[2]/div[2]/div/div[2]/a[3]"
		)
		await link[0].click()

		// Fill in the key input
		const input1 = await page.$x(
			"/html/body/div[1]/div/div/div/div[6]/form/div[2]/input"
		)
		await input1[0].click()
		await (
			await page.$x("/html/body/div[1]/div/div/div/div[6]/form/div[2]/input")
		)[0].type("test", { delay: 100 })

		// Fill in the value input
		const input2 = await page.$x(
			"/html/body/div[1]/div/div/div/div[6]/form/div[2]/input"
		)
		await input2[0].click()
		await (
			await page.$x("/html/body/div[1]/div/div/div/div[6]/form/div[3]/input")
		)[0].type("hello-world", { delay: 100 })

		// Asserts the form should be filled
		await expect(page).toFillForm('form[name="createAnAuthenticationToken"]', {
			key: "test",
			value: "hello-world",
		})
	}, 100000)

	it("clicks submit on the form", async () => {
		await page.click("button", { text: "Save token" })
		await expect(page).toClick("button", { text: "Save token" })

		await new Promise((r) => setTimeout(r, 5000))
	}, 100000)

	it("deletes the token", async () => {
		const button1 = await page.$x(
			"/html/body/div[1]/div/div/div/div[6]/div[5]/button"
		)
		await button1[0].click()

		await new Promise((r) => setTimeout(r, 5000))
		await expect(page).not.toMatch("hello-world")
	}, 100000)
})
```

The frontend team Meeshkan uses [NX](https://nx.dev/latest/react/getting-started/getting-started) as a set of devtools to manage our monorepo. It makes it super slick to run tests, deploy incrementally, share resources (called libs), etc.

![jest](https://media.graphcms.com/Upz4kRbJTyhaGu2mflW7)

So our test command is not likely how you'd do it. Depending on your set up, you'll run something like:

```bash
jest
```

This is where you would take the time to swap out your base URL (process.env.TEST_URL), and add cookies if your service/user story requires you to be signed up.

Once you've verified the behavior locally, we'll implement this new found functionality in our GitHub action!

![Green checks on GitHub](https://media.graphcms.com/n0fMVuMRThmkPM6bOEwo)

Now in order to get the green checks on a GitHub PR, more specific conditons will need to be met. The file will now read:

```yaml
#  main.yaml
name: Meeshkan tests

on: push

jobs:
  run-jest-puppeteer-scripts:
  name: Run the puppeteer scripts generated by Meeshkan
  runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v1
        with:
          node-version: '14'

      - name: Install dependencies & Run test
        run: |
          yarn install --prefer-offline --frozen-lockfile
          jest
```

### 4. Bonus â€” using await-vercel

Since Meeshkan uses [Vercel](https://vercel.com), we also implemented an interesting workaround to test our hosted staging environment instead of a local build. The GitHub action [await-vercel](https://github.com/marketplace/actions/await-for-vercel-deployment) allows us to define the URL and poll for it to be finished deploying.

We'd suggest a parallel setup for whichever host you use as some issues only come out of the woodwork when hosted rather than local.

First we add a job to the beggining of our `main.yml` file. You'll then add your team's [Vercel token](https://vercel.com/account/tokens) as a [GitHub secret](https://docs.github.com/en/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository) to the repository you're testing and pass it as an environment variable.

```yml
#  main.yaml
jobs:
  wait-for-vercel-deployment:
    runs-on: ubuntu-18.04
    steps:
      - uses: UnlyEd/github-action-await-vercel@v1.1.0
        id: await-vercel
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
```

If you were to only be testing against a non-closing branch like staging, you can pass the `deployment-url` hardcoded as such:

```diff
+        with:
+         deployment-url: your-env-team.vercel.app
```

If you work with feature branches, we'll need to set this dynamically! We'll add three new steps that

1. Get the branch name and then
2. transform that to the deployment url which is stored as a step variable named `branch` and finally
3. Display the status of the deployment url.

![Vercel settings](https://media.graphcms.com/34nmqPBQznSIExdDKkiw)

Vercel uses a deployment URL pattern of `${projectName}-git-${branchName}-${teamName}.vercel.app`. You can find the project name and team name in the URL or settings of your project. Our project name in this screenshot is `webapp` and team name `meeshkanml`.

This is our vercel await configuration so far:

```yaml
#  main.yaml
jobs:
  wait-for-vercel-deployment:
    runs-on: ubuntu-18.04
    steps:
      - name: Get branch name
        id: branch
        run: echo "##[set-output name=branch;]$(echo ${GITHUB_REF#refs/heads/})"

      - name: Get deploy url
        id: url
        run: echo webapp-git-${{ steps.branch.outputs.branch }}-meeshkanml.vercel.app

      - uses: UnlyEd/github-action-await-vercel@v1.1.0
        id: await-vercel
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
        with:
          deployment-url: webapp-git-${{ steps.branch.outputs.branch }}-meeshkanml.vercel.app
          timeout: 60 # Wait for 1 minute before failing

      - name: Display deployment status
        run: "echo The deployment at ${{ fromJson(steps.await-vercel.outputs.deploymentDetails).url }} is ${{ fromJson(steps.await-vercel.outputs.deploymentDetails).readyState }}"
```

Finally, you'll want to make sure that this step blocks your testing step that we setup above! You'll do this by passing `needs: wait-for-vercel-deployment` to the `run-jest-puppeteer-tests` step.

```yml
#  main.yaml
name: Meeshkan tests

on: push

jobs:
  wait-for-vercel-deployment:
    # what we wrote for waiting for vercel here

  run-jest-puppeteer-tests:
    needs: wait-for-vercel-deployment
    # what we wrote for running tests here
```

## In conclusion

Meeshkan outputting Puppeteer scripts is the first step in running tests generated by your users for a better release experience. The way in which you implement may vary from the above but feel free to <a onClick={() => {window.Intercom("showMessages")}}>chat with us</a> if you have configuration questions!
